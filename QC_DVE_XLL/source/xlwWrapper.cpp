//// 
//// Autogenerated by xlw 
//// Do not edit this file, it will be overwritten 
//// by InterfaceGenerator 
////

#include "xlw/MyContainers.h"
#include <xlw/CellMatrix.h>
#include "cppinterface.h"
#include <xlw/xlw.h>
#include <xlw/XlFunctionRegistration.h>
#include <stdexcept>
#include <xlw/XlOpenClose.h>
#include <xlw/HiResTimer.h>
using namespace xlw;

namespace {
const char* LibraryName = "QC_DVE";
};


// registrations start here


namespace
{
XLRegistration::Arg
EchoShortArgs[]=
{
{ "x"," number to be echoed ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerEchoShort("xlEchoShort",
"EchoShort",
" echoes a short ",
LibraryName,
EchoShortArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlEchoShort(
LPXLFOPER xa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper xb(
	(xa));
short x(
	xb.AsShort("x"));

short result(
	EchoShort(
		x)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
suumaArgs[]=
{
{ "x","primer numero ","B"},
{ "y","segundo numero ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registersuuma("xlsuuma",
"suuma",
"Devuelve la suma de 2 numeros ",
LibraryName,
suumaArgs,
2
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlsuuma(
double x,
double y)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);



double result(
	suuma(
		x,
		y)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
qcYearFractionArgs[]=
{
{ "startDate","Fecha inicial ","B"},
{ "endDate","Fecha final ","B"},
{ "yf","Nombre de la fraccion de agno ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerqcYearFraction("xlqcYearFraction",
"qcYearFraction",
"Devuelve la fraccion de agno entre dos fechas ",
LibraryName,
qcYearFractionArgs,
3
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlqcYearFraction(
double startDatea,
double endDatea,
LPXLFOPER yfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

int startDate(
	static_cast<int>(startDatea));

int endDate(
	static_cast<int>(endDatea));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

double result(
	qcYearFraction(
		startDate,
		endDate,
		yf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
qcWealthFactorArgs[]=
{
{ "rate","Valor de la tasa ","B"},
{ "stDt","Fecha inicial ","B"},
{ "endDt","Fecha final ","B"},
{ "yf","Tipo de fraccion de agno ","XLF_OPER"},
{ "wf","Tipo de factor de capitalacion ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerqcWealthFactor("xlqcWealthFactor",
"qcWealthFactor",
"Devuelve el factor de capitalizacion de una tasa entre 2 fechas ",
LibraryName,
qcWealthFactorArgs,
5
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlqcWealthFactor(
double rate,
double stDta,
double endDta,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


int stDt(
	static_cast<int>(stDta));

int endDt(
	static_cast<int>(endDta));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

double result(
	qcWealthFactor(
		rate,
		stDt,
		endDt,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
cashFlowArgs[]=
{
{ "tablaDesarrollo","too lazy to comment this one ","XLF_OPER"},
{ "tasa","too lazy to comment this one ","B"},
{ "fecha","too lazy to comment this one ","B"},
{ "yf","too lazy to comment this one ","XLF_OPER"},
{ "wf","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registercashFlow("xlcashFlow",
"cashFlow",
"too lazy to comment this function ",
LibraryName,
cashFlowArgs,
5
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlcashFlow(
LPXLFOPER tablaDesarrolloa,
double tasa,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));


int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

CellMatrix result(
	cashFlow(
		tablaDesarrollo,
		tasa,
		fecha,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvFixed1Args[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "curva","Curva cero cupon (rango con tenors y tasas) ","XLF_OPER"},
{ "tasa","valor de la tasa fija de la pata ","B"},
{ "fecha","fecha de valorizacion ","B"},
{ "yf","nombre de la fraccion de agno de la tasa fija ","XLF_OPER"},
{ "wf","nombre del tipo de factor de capitalizacion ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvFixed1("xlpvFixed1",
"pvFixed1",
"too lazy to comment this function ",
LibraryName,
pvFixed1Args,
6
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvFixed1(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER curvaa,
double tasa,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper curvab(
	(curvaa));
CellMatrix curva(
	curvab.AsCellMatrix("curva"));


int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

double result(
	pvFixed1(
		tablaDesarrollo,
		curva,
		tasa,
		fecha,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvFloat1Args[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "curvaProy","Curva de proyeccion ","XLF_OPER"},
{ "curvaDesc","Curva de descuento ","XLF_OPER"},
{ "pastFixings","Fixings anteriores ","XLF_OPER"},
{ "addSpread","Spread aditivo ","B"},
{ "multSpread","Spread multiplicativo ","B"},
{ "fecha","Fecha de valorizacion ","B"},
{ "yf","Yf de la tasa flotante ","XLF_OPER"},
{ "wf","Wf de la tasa flotante ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvFloat1("xlpvFloat1",
"pvFloat1",
"too lazy to comment this function ",
LibraryName,
pvFloat1Args,
9
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvFloat1(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER curvaProya,
LPXLFOPER curvaDesca,
LPXLFOPER pastFixingsa,
double addSpread,
double multSpread,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper curvaProyb(
	(curvaProya));
CellMatrix curvaProy(
	curvaProyb.AsCellMatrix("curvaProy"));

XlfOper curvaDescb(
	(curvaDesca));
CellMatrix curvaDesc(
	curvaDescb.AsCellMatrix("curvaDesc"));

XlfOper pastFixingsb(
	(pastFixingsa));
CellMatrix pastFixings(
	pastFixingsb.AsCellMatrix("pastFixings"));



int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

double result(
	pvFloat1(
		tablaDesarrollo,
		curvaProy,
		curvaDesc,
		pastFixings,
		addSpread,
		multSpread,
		fecha,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvIcpClp1Args[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "curvaProy","Curva de proyeccion ","XLF_OPER"},
{ "curvaDesc","Curva de descuento ","XLF_OPER"},
{ "pastFixings","Fixings pasados de ICP ","XLF_OPER"},
{ "addSpread","Spread aditivo ","B"},
{ "multSpread","Spread multiplicativo ","B"},
{ "fecha","Fecha de valorizacion ","B"},
{ "yf","Fraccion de a o de la tasa flotante ","XLF_OPER"},
{ "wf","Factor de capitalizacion de la tasa flotante ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvIcpClp1("xlpvIcpClp1",
"pvIcpClp1",
"too lazy to comment this function ",
LibraryName,
pvIcpClp1Args,
9
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvIcpClp1(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER curvaProya,
LPXLFOPER curvaDesca,
LPXLFOPER pastFixingsa,
double addSpread,
double multSpread,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper curvaProyb(
	(curvaProya));
CellMatrix curvaProy(
	curvaProyb.AsCellMatrix("curvaProy"));

XlfOper curvaDescb(
	(curvaDesca));
CellMatrix curvaDesc(
	curvaDescb.AsCellMatrix("curvaDesc"));

XlfOper pastFixingsb(
	(pastFixingsa));
CellMatrix pastFixings(
	pastFixingsb.AsCellMatrix("pastFixings"));



int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

double result(
	pvIcpClp1(
		tablaDesarrollo,
		curvaProy,
		curvaDesc,
		pastFixings,
		addSpread,
		multSpread,
		fecha,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvIcpClpArgs[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "curvaProy","Curva de proyeccion ","XLF_OPER"},
{ "curvaDesc","Curva de descuento ","XLF_OPER"},
{ "pastFixings","Fixings pasados de ICP ","XLF_OPER"},
{ "addSpread","Spread aditivo ","B"},
{ "multSpread","Spread multiplicativo ","B"},
{ "fecha","Fecha de valorizacion ","B"},
{ "yf","Fraccion de a o de la tasa flotante ","XLF_OPER"},
{ "wf","Factor de capitalizacion de la tasa flotante ","XLF_OPER"},
{ "curveYf","Fraccion de agno de la curva ","XLF_OPER"},
{ "curveWf","Factor de capitalizacion de la curva ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvIcpClp("xlpvIcpClp",
"pvIcpClp",
"too lazy to comment this function ",
LibraryName,
pvIcpClpArgs,
11
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvIcpClp(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER curvaProya,
LPXLFOPER curvaDesca,
LPXLFOPER pastFixingsa,
double addSpread,
double multSpread,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa,
LPXLFOPER curveYfa,
LPXLFOPER curveWfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper curvaProyb(
	(curvaProya));
CellMatrix curvaProy(
	curvaProyb.AsCellMatrix("curvaProy"));

XlfOper curvaDescb(
	(curvaDesca));
CellMatrix curvaDesc(
	curvaDescb.AsCellMatrix("curvaDesc"));

XlfOper pastFixingsb(
	(pastFixingsa));
CellMatrix pastFixings(
	pastFixingsb.AsCellMatrix("pastFixings"));



int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

XlfOper curveYfb(
	(curveYfa));
string curveYf(
	curveYfb.AsString("curveYf"));

XlfOper curveWfb(
	(curveWfa));
string curveWf(
	curveWfb.AsString("curveWf"));

double result(
	pvIcpClp(
		tablaDesarrollo,
		curvaProy,
		curvaDesc,
		pastFixings,
		addSpread,
		multSpread,
		fecha,
		yf,
		wf,
		curveYf,
		curveWf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvIcpClfArgs[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "curvaProy","Curva de proyeccion ","XLF_OPER"},
{ "curvaDesc","Curva de descuento ","XLF_OPER"},
{ "pastFixings","Fixings pasados de ICP ","XLF_OPER"},
{ "ufFixings","Fixings pasado de UF ","XLF_OPER"},
{ "addSpread","Spread aditivo ","B"},
{ "multSpread","Spread multiplicativo ","B"},
{ "fecha","Fecha de valorizacion ","B"},
{ "yf","Fraccion de a o de la tasa flotante ","XLF_OPER"},
{ "wf","Factor de capitalizacion de la tasa flotante ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvIcpClf("xlpvIcpClf",
"pvIcpClf",
"too lazy to comment this function ",
LibraryName,
pvIcpClfArgs,
10
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvIcpClf(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER curvaProya,
LPXLFOPER curvaDesca,
LPXLFOPER pastFixingsa,
LPXLFOPER ufFixingsa,
double addSpread,
double multSpread,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper curvaProyb(
	(curvaProya));
CellMatrix curvaProy(
	curvaProyb.AsCellMatrix("curvaProy"));

XlfOper curvaDescb(
	(curvaDesca));
CellMatrix curvaDesc(
	curvaDescb.AsCellMatrix("curvaDesc"));

XlfOper pastFixingsb(
	(pastFixingsa));
CellMatrix pastFixings(
	pastFixingsb.AsCellMatrix("pastFixings"));

XlfOper ufFixingsb(
	(ufFixingsa));
CellMatrix ufFixings(
	ufFixingsb.AsCellMatrix("ufFixings"));



int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

double result(
	pvIcpClf(
		tablaDesarrollo,
		curvaProy,
		curvaDesc,
		pastFixings,
		ufFixings,
		addSpread,
		multSpread,
		fecha,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvFixedLegsArgs[]=
{
{ "valueDate","too lazy to comment this one ","B"},
{ "holidays","too lazy to comment this one ","XLF_OPER"},
{ "curveValues","too lazy to comment this one ","XLF_OPER"},
{ "curveCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "legCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "customAmort","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvFixedLegs("xlpvFixedLegs",
"pvFixedLegs",
"too lazy to comment this function ",
LibraryName,
pvFixedLegsArgs,
6
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvFixedLegs(
double valueDate,
LPXLFOPER holidaysa,
LPXLFOPER curveValuesa,
LPXLFOPER curveCharacteristicsa,
LPXLFOPER legCharacteristicsa,
LPXLFOPER customAmorta)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper curveValuesb(
	(curveValuesa));
CellMatrix curveValues(
	curveValuesb.AsCellMatrix("curveValues"));

XlfOper curveCharacteristicsb(
	(curveCharacteristicsa));
CellMatrix curveCharacteristics(
	curveCharacteristicsb.AsCellMatrix("curveCharacteristics"));

XlfOper legCharacteristicsb(
	(legCharacteristicsa));
CellMatrix legCharacteristics(
	legCharacteristicsb.AsCellMatrix("legCharacteristics"));

XlfOper customAmortb(
	(customAmorta));
CellMatrix customAmort(
	customAmortb.AsCellMatrix("customAmort"));

CellMatrix result(
	pvFixedLegs(
		valueDate,
		holidays,
		curveValues,
		curveCharacteristics,
		legCharacteristics,
		customAmort)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvIcpClpLegsArgs[]=
{
{ "valueDate","too lazy to comment this one ","B"},
{ "holidays","too lazy to comment this one ","XLF_OPER"},
{ "curveValues","too lazy to comment this one ","XLF_OPER"},
{ "curveCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "legCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "customAmort","too lazy to comment this one ","XLF_OPER"},
{ "fixings","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvIcpClpLegs("xlpvIcpClpLegs",
"pvIcpClpLegs",
"too lazy to comment this function ",
LibraryName,
pvIcpClpLegsArgs,
7
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvIcpClpLegs(
double valueDate,
LPXLFOPER holidaysa,
LPXLFOPER curveValuesa,
LPXLFOPER curveCharacteristicsa,
LPXLFOPER legCharacteristicsa,
LPXLFOPER customAmorta,
LPXLFOPER fixingsa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper curveValuesb(
	(curveValuesa));
CellMatrix curveValues(
	curveValuesb.AsCellMatrix("curveValues"));

XlfOper curveCharacteristicsb(
	(curveCharacteristicsa));
CellMatrix curveCharacteristics(
	curveCharacteristicsb.AsCellMatrix("curveCharacteristics"));

XlfOper legCharacteristicsb(
	(legCharacteristicsa));
CellMatrix legCharacteristics(
	legCharacteristicsb.AsCellMatrix("legCharacteristics"));

XlfOper customAmortb(
	(customAmorta));
CellMatrix customAmort(
	customAmortb.AsCellMatrix("customAmort"));

XlfOper fixingsb(
	(fixingsa));
CellMatrix fixings(
	fixingsb.AsCellMatrix("fixings"));

CellMatrix result(
	pvIcpClpLegs(
		valueDate,
		holidays,
		curveValues,
		curveCharacteristics,
		legCharacteristics,
		customAmort,
		fixings)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

//////////////////////////
// Methods that will get registered to execute in AutoOpen
//////////////////////////

//////////////////////////
// Methods that will get registered to execute in AutoClose
//////////////////////////

