//// 
//// Autogenerated by xlw 
//// Do not edit this file, it will be overwritten 
//// by InterfaceGenerator 
////

#include "xlw/MyContainers.h"
#include <xlw/CellMatrix.h>
#include "cppinterface.h"
#include <xlw/xlw.h>
#include <xlw/XlFunctionRegistration.h>
#include <stdexcept>
#include <xlw/XlOpenClose.h>
#include <xlw/HiResTimer.h>
using namespace xlw;

namespace {
const char* LibraryName = "QC_DVE";
};


// registrations start here


namespace
{
  XLRegistration::XLFunctionRegistrationHelper
registerQCGetMacAddress("xlQCGetMacAddress",
"QCGetMacAddress",
"too lazy to comment this function ",
LibraryName,
0,
0
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCGetMacAddress(
)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

string result(
	QCGetMacAddress());
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCSha256Args[]=
{
{ "input","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCSha256("xlQCSha256",
"QCSha256",
"too lazy to comment this function ",
LibraryName,
QCSha256Args,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCSha256(
LPXLFOPER inputa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper inputb(
	(inputa));
string input(
	inputb.AsString("input"));

string result(
	QCSha256(
		input)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
  XLRegistration::XLFunctionRegistrationHelper
registerQCGetAuthKey("xlQCGetAuthKey",
"QCGetAuthKey",
"too lazy to comment this function ",
LibraryName,
0,
0
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCGetAuthKey(
)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

string result(
	QCGetAuthKey());
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCGenerateKeyArgs[]=
{
{ "password","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCGenerateKey("xlQCGenerateKey",
"QCGenerateKey",
"too lazy to comment this function ",
LibraryName,
QCGenerateKeyArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCGenerateKey(
LPXLFOPER passworda)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper passwordb(
	(passworda));
string password(
	passwordb.AsString("password"));

string result(
	QCGenerateKey(
		password)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCBootZeroRatesFixedLegsArgs[]=
{
{ "xlValueDate","Fecha de calculo ","B"},
{ "xlInputRates","Rango con datos de tasas ","XLF_OPER"},
{ "xlInputFixedLegs","Rango con datos de patas fijas ","XLF_OPER"},
{ "calendar","Rango con feriados a aplicar ","XLF_OPER"},
{ "interpolator","Forma de interpolacion de la curva ","XLF_OPER"},
{ "curveWf","Factor de capitalizacion de la curva ","XLF_OPER"},
{ "curveYf","Fraccion de a o de las tasas de la curva ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCBootZeroRatesFixedLegs("xlQCBootZeroRatesFixedLegs",
"QCBootZeroRatesFixedLegs",
"Realiza el bootstrapping a partir de tasas cero y patas fijas ",
LibraryName,
QCBootZeroRatesFixedLegsArgs,
7
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCBootZeroRatesFixedLegs(
double xlValueDatea,
LPXLFOPER xlInputRatesa,
LPXLFOPER xlInputFixedLegsa,
LPXLFOPER calendara,
LPXLFOPER interpolatora,
LPXLFOPER curveWfa,
LPXLFOPER curveYfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

int xlValueDate(
	static_cast<int>(xlValueDatea));

XlfOper xlInputRatesb(
	(xlInputRatesa));
CellMatrix xlInputRates(
	xlInputRatesb.AsCellMatrix("xlInputRates"));

XlfOper xlInputFixedLegsb(
	(xlInputFixedLegsa));
CellMatrix xlInputFixedLegs(
	xlInputFixedLegsb.AsCellMatrix("xlInputFixedLegs"));

XlfOper calendarb(
	(calendara));
CellMatrix calendar(
	calendarb.AsCellMatrix("calendar"));

XlfOper interpolatorb(
	(interpolatora));
string interpolator(
	interpolatorb.AsString("interpolator"));

XlfOper curveWfb(
	(curveWfa));
string curveWf(
	curveWfb.AsString("curveWf"));

XlfOper curveYfb(
	(curveYfa));
string curveYf(
	curveYfb.AsString("curveYf"));

CellMatrix result(
	QCBootZeroRatesFixedLegs(
		xlValueDate,
		xlInputRates,
		xlInputFixedLegs,
		calendar,
		interpolator,
		curveWf,
		curveYf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCBootZeroRatesFwdsFixedLegsArgs[]=
{
{ "xlValueDate","Fecha de calculo ","B"},
{ "fx","Tipo de cambio spot ","B"},
{ "xlInputRates","Rango con input de tasas ","XLF_OPER"},
{ "xlInputForwards","Rango con input de forwards ","XLF_OPER"},
{ "whichLeg","Indica que pata de los forwards se usa ","B"},
{ "xlInputFixedLegs","Input de patas fijas ","XLF_OPER"},
{ "curveInterpolator","Interpolacion de la curva a construir ","XLF_OPER"},
{ "curveYf","Fraccion de a o de las tasas de la curva a construir ","XLF_OPER"},
{ "curveWf","Factor de capitalizacion de las tasas de la curva a construir ","XLF_OPER"},
{ "holidays","Vector con feriados aplicables ","XLF_OPER"},
{ "auxCurve","Plazos y tasas curva auxiliar (de los forwards) ","XLF_OPER"},
{ "auxCurveInterpolator","Interpolacion de la curva auxiliar ","XLF_OPER"},
{ "auxCurveYf","Fraccion de a o de las tasas de la curva auxiliar ","XLF_OPER"},
{ "auxCurveWf","Factor de capitalizacion de las tasas de la curva auxiliar ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCBootZeroRatesFwdsFixedLegs("xlQCBootZeroRatesFwdsFixedLegs",
"QCBootZeroRatesFwdsFixedLegs",
"Realiza el bootstrapping a partir de tasas cero, fx fwds y patas fijas ",
LibraryName,
QCBootZeroRatesFwdsFixedLegsArgs,
14
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCBootZeroRatesFwdsFixedLegs(
double xlValueDate,
double fx,
LPXLFOPER xlInputRatesa,
LPXLFOPER xlInputForwardsa,
double whichLega,
LPXLFOPER xlInputFixedLegsa,
LPXLFOPER curveInterpolatora,
LPXLFOPER curveYfa,
LPXLFOPER curveWfa,
LPXLFOPER holidaysa,
LPXLFOPER auxCurvea,
LPXLFOPER auxCurveInterpolatora,
LPXLFOPER auxCurveYfa,
LPXLFOPER auxCurveWfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);



XlfOper xlInputRatesb(
	(xlInputRatesa));
CellMatrix xlInputRates(
	xlInputRatesb.AsCellMatrix("xlInputRates"));

XlfOper xlInputForwardsb(
	(xlInputForwardsa));
CellMatrix xlInputForwards(
	xlInputForwardsb.AsCellMatrix("xlInputForwards"));

int whichLeg(
	static_cast<int>(whichLega));

XlfOper xlInputFixedLegsb(
	(xlInputFixedLegsa));
CellMatrix xlInputFixedLegs(
	xlInputFixedLegsb.AsCellMatrix("xlInputFixedLegs"));

XlfOper curveInterpolatorb(
	(curveInterpolatora));
string curveInterpolator(
	curveInterpolatorb.AsString("curveInterpolator"));

XlfOper curveYfb(
	(curveYfa));
string curveYf(
	curveYfb.AsString("curveYf"));

XlfOper curveWfb(
	(curveWfa));
string curveWf(
	curveWfb.AsString("curveWf"));

XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper auxCurveb(
	(auxCurvea));
CellMatrix auxCurve(
	auxCurveb.AsCellMatrix("auxCurve"));

XlfOper auxCurveInterpolatorb(
	(auxCurveInterpolatora));
string auxCurveInterpolator(
	auxCurveInterpolatorb.AsString("auxCurveInterpolator"));

XlfOper auxCurveYfb(
	(auxCurveYfa));
string auxCurveYf(
	auxCurveYfb.AsString("auxCurveYf"));

XlfOper auxCurveWfb(
	(auxCurveWfa));
string auxCurveWf(
	auxCurveWfb.AsString("auxCurveWf"));

CellMatrix result(
	QCBootZeroRatesFwdsFixedLegs(
		xlValueDate,
		fx,
		xlInputRates,
		xlInputForwards,
		whichLeg,
		xlInputFixedLegs,
		curveInterpolator,
		curveYf,
		curveWf,
		holidays,
		auxCurve,
		auxCurveInterpolator,
		auxCurveYf,
		auxCurveWf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCBootZeroRatesFwdsFloatingLegsArgs[]=
{
{ "xlValueDate","Fecha de calculo ","B"},
{ "fx","Tipo de cambio spot ","B"},
{ "fixing","Fixing de la primera tasa flotante ","B"},
{ "xlInputRates","Rango con input de tasas ","XLF_OPER"},
{ "xlInputForwards","Rango con input de forwards ","XLF_OPER"},
{ "fwdPoints","Debe decir si o no. Indica si los precios son o no puntos fwd ","XLF_OPER"},
{ "fwdsHolidays","Nombre del calendario de sett de fwds ","XLF_OPER"},
{ "whichLeg","Indica que pata de los fwds se usa ","B"},
{ "xlInputFloatingLegs","Rango con input de patas flotantes ","XLF_OPER"},
{ "xlInputIndexChars","Rango con las caracteristicas del indice flotante ","XLF_OPER"},
{ "curveInterpolator","Interpolacion de la curva a construir ","XLF_OPER"},
{ "curveYf","Fraccion de a o de las tasas de la curva a construir ","XLF_OPER"},
{ "curveWf","Factor de capitalizacion de las tasas de la curva a construir ","XLF_OPER"},
{ "holidays","Rango con todos los feriados ","XLF_OPER"},
{ "fwdsCurve","Plazos y tasas de la curva auxiliar de los fwds ","XLF_OPER"},
{ "fwdsCurveInterpolator","Interpolacion de la curva de los fwds ","XLF_OPER"},
{ "fwdsCurveYf","Fraccion de agno de las tasas de la curva de los fwds ","XLF_OPER"},
{ "fwdsCurveWf","Factor de capitalizacion de las tasas de la curva de los fwds ","XLF_OPER"},
{ "floatCurve","Plazos y tasas de la curva auxiliar de las patas flotantes ","XLF_OPER"},
{ "floatCurveInterpolator","Interpolacion de la curva de proyeccion de las patas flotantes ","XLF_OPER"},
{ "floatCurveYf","Fraccion de agno de las tasas de la curva de proyeccion de las patas flotantes ","XLF_OPER"},
{ "floatCurveWf","Factor de capitalizacion de las tasas de la curva de proyeccion de las patas flotantes ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCBootZeroRatesFwdsFloatingLegs("xlQCBootZeroRatesFwdsFloatingLegs",
"QCBootZeroRatesFwdsFloatingLegs",
"Realiza el bootstrapping a partir de tasas cero, fx fwds y patas flotantes ",
LibraryName,
QCBootZeroRatesFwdsFloatingLegsArgs,
22
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCBootZeroRatesFwdsFloatingLegs(
double xlValueDate,
double fx,
double fixing,
LPXLFOPER xlInputRatesa,
LPXLFOPER xlInputForwardsa,
LPXLFOPER fwdPointsa,
LPXLFOPER fwdsHolidaysa,
double whichLega,
LPXLFOPER xlInputFloatingLegsa,
LPXLFOPER xlInputIndexCharsa,
LPXLFOPER curveInterpolatora,
LPXLFOPER curveYfa,
LPXLFOPER curveWfa,
LPXLFOPER holidaysa,
LPXLFOPER fwdsCurvea,
LPXLFOPER fwdsCurveInterpolatora,
LPXLFOPER fwdsCurveYfa,
LPXLFOPER fwdsCurveWfa,
LPXLFOPER floatCurvea,
LPXLFOPER floatCurveInterpolatora,
LPXLFOPER floatCurveYfa,
LPXLFOPER floatCurveWfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);




XlfOper xlInputRatesb(
	(xlInputRatesa));
CellMatrix xlInputRates(
	xlInputRatesb.AsCellMatrix("xlInputRates"));

XlfOper xlInputForwardsb(
	(xlInputForwardsa));
CellMatrix xlInputForwards(
	xlInputForwardsb.AsCellMatrix("xlInputForwards"));

XlfOper fwdPointsb(
	(fwdPointsa));
string fwdPoints(
	fwdPointsb.AsString("fwdPoints"));

XlfOper fwdsHolidaysb(
	(fwdsHolidaysa));
string fwdsHolidays(
	fwdsHolidaysb.AsString("fwdsHolidays"));

int whichLeg(
	static_cast<int>(whichLega));

XlfOper xlInputFloatingLegsb(
	(xlInputFloatingLegsa));
CellMatrix xlInputFloatingLegs(
	xlInputFloatingLegsb.AsCellMatrix("xlInputFloatingLegs"));

XlfOper xlInputIndexCharsb(
	(xlInputIndexCharsa));
CellMatrix xlInputIndexChars(
	xlInputIndexCharsb.AsCellMatrix("xlInputIndexChars"));

XlfOper curveInterpolatorb(
	(curveInterpolatora));
string curveInterpolator(
	curveInterpolatorb.AsString("curveInterpolator"));

XlfOper curveYfb(
	(curveYfa));
string curveYf(
	curveYfb.AsString("curveYf"));

XlfOper curveWfb(
	(curveWfa));
string curveWf(
	curveWfb.AsString("curveWf"));

XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper fwdsCurveb(
	(fwdsCurvea));
CellMatrix fwdsCurve(
	fwdsCurveb.AsCellMatrix("fwdsCurve"));

XlfOper fwdsCurveInterpolatorb(
	(fwdsCurveInterpolatora));
string fwdsCurveInterpolator(
	fwdsCurveInterpolatorb.AsString("fwdsCurveInterpolator"));

XlfOper fwdsCurveYfb(
	(fwdsCurveYfa));
string fwdsCurveYf(
	fwdsCurveYfb.AsString("fwdsCurveYf"));

XlfOper fwdsCurveWfb(
	(fwdsCurveWfa));
string fwdsCurveWf(
	fwdsCurveWfb.AsString("fwdsCurveWf"));

XlfOper floatCurveb(
	(floatCurvea));
CellMatrix floatCurve(
	floatCurveb.AsCellMatrix("floatCurve"));

XlfOper floatCurveInterpolatorb(
	(floatCurveInterpolatora));
string floatCurveInterpolator(
	floatCurveInterpolatorb.AsString("floatCurveInterpolator"));

XlfOper floatCurveYfb(
	(floatCurveYfa));
string floatCurveYf(
	floatCurveYfb.AsString("floatCurveYf"));

XlfOper floatCurveWfb(
	(floatCurveWfa));
string floatCurveWf(
	floatCurveWfb.AsString("floatCurveWf"));

CellMatrix result(
	QCBootZeroRatesFwdsFloatingLegs(
		xlValueDate,
		fx,
		fixing,
		xlInputRates,
		xlInputForwards,
		fwdPoints,
		fwdsHolidays,
		whichLeg,
		xlInputFloatingLegs,
		xlInputIndexChars,
		curveInterpolator,
		curveYf,
		curveWf,
		holidays,
		fwdsCurve,
		fwdsCurveInterpolator,
		fwdsCurveYf,
		fwdsCurveWf,
		floatCurve,
		floatCurveInterpolator,
		floatCurveYf,
		floatCurveWf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
checkBoostrappingFwdsArgs[]=
{
{ "xlValueDate","too lazy to comment this one ","B"},
{ "xlInputRates","too lazy to comment this one ","XLF_OPER"},
{ "xlInputForwards","too lazy to comment this one ","XLF_OPER"},
{ "whichLeg","too lazy to comment this one ","B"},
{ "xlInputFixedLegs","too lazy to comment this one ","XLF_OPER"},
{ "calendar","too lazy to comment this one ","XLF_OPER"},
{ "auxCurve","too lazy to comment this one ","XLF_OPER"},
{ "fx","too lazy to comment this one ","B"},
{ "interpolator","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registercheckBoostrappingFwds("xlcheckBoostrappingFwds",
"checkBoostrappingFwds",
"too lazy to comment this function ",
LibraryName,
checkBoostrappingFwdsArgs,
9
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlcheckBoostrappingFwds(
double xlValueDatea,
LPXLFOPER xlInputRatesa,
LPXLFOPER xlInputForwardsa,
double whichLega,
LPXLFOPER xlInputFixedLegsa,
LPXLFOPER calendara,
LPXLFOPER auxCurvea,
double fx,
LPXLFOPER interpolatora)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

int xlValueDate(
	static_cast<int>(xlValueDatea));

XlfOper xlInputRatesb(
	(xlInputRatesa));
CellMatrix xlInputRates(
	xlInputRatesb.AsCellMatrix("xlInputRates"));

XlfOper xlInputForwardsb(
	(xlInputForwardsa));
CellMatrix xlInputForwards(
	xlInputForwardsb.AsCellMatrix("xlInputForwards"));

int whichLeg(
	static_cast<int>(whichLega));

XlfOper xlInputFixedLegsb(
	(xlInputFixedLegsa));
CellMatrix xlInputFixedLegs(
	xlInputFixedLegsb.AsCellMatrix("xlInputFixedLegs"));

XlfOper calendarb(
	(calendara));
CellMatrix calendar(
	calendarb.AsCellMatrix("calendar"));

XlfOper auxCurveb(
	(auxCurvea));
CellMatrix auxCurve(
	auxCurveb.AsCellMatrix("auxCurve"));


XlfOper interpolatorb(
	(interpolatora));
string interpolator(
	interpolatorb.AsString("interpolator"));

CellMatrix result(
	checkBoostrappingFwds(
		xlValueDate,
		xlInputRates,
		xlInputForwards,
		whichLeg,
		xlInputFixedLegs,
		calendar,
		auxCurve,
		fx,
		interpolator)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
checkBoostrappingFwdsFloatingArgs[]=
{
{ "xlValueDate","too lazy to comment this one ","B"},
{ "xlInputRates","too lazy to comment this one ","XLF_OPER"},
{ "xlInputForwards","too lazy to comment this one ","XLF_OPER"},
{ "whichLeg","too lazy to comment this one ","B"},
{ "xlInputFloatingLegs","too lazy to comment this one ","XLF_OPER"},
{ "holidays","too lazy to comment this one ","XLF_OPER"},
{ "intRateIndexChars","too lazy to comment this one ","XLF_OPER"},
{ "auxCurveFwd","too lazy to comment this one ","XLF_OPER"},
{ "auxCurveFloating","too lazy to comment this one ","XLF_OPER"},
{ "fx","too lazy to comment this one ","B"},
{ "fixing","too lazy to comment this one ","B"},
{ "interpolator","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registercheckBoostrappingFwdsFloating("xlcheckBoostrappingFwdsFloating",
"checkBoostrappingFwdsFloating",
"too lazy to comment this function ",
LibraryName,
checkBoostrappingFwdsFloatingArgs,
12
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlcheckBoostrappingFwdsFloating(
double xlValueDatea,
LPXLFOPER xlInputRatesa,
LPXLFOPER xlInputForwardsa,
double whichLega,
LPXLFOPER xlInputFloatingLegsa,
LPXLFOPER holidaysa,
LPXLFOPER intRateIndexCharsa,
LPXLFOPER auxCurveFwda,
LPXLFOPER auxCurveFloatinga,
double fx,
double fixing,
LPXLFOPER interpolatora)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

int xlValueDate(
	static_cast<int>(xlValueDatea));

XlfOper xlInputRatesb(
	(xlInputRatesa));
CellMatrix xlInputRates(
	xlInputRatesb.AsCellMatrix("xlInputRates"));

XlfOper xlInputForwardsb(
	(xlInputForwardsa));
CellMatrix xlInputForwards(
	xlInputForwardsb.AsCellMatrix("xlInputForwards"));

int whichLeg(
	static_cast<int>(whichLega));

XlfOper xlInputFloatingLegsb(
	(xlInputFloatingLegsa));
CellMatrix xlInputFloatingLegs(
	xlInputFloatingLegsb.AsCellMatrix("xlInputFloatingLegs"));

XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper intRateIndexCharsb(
	(intRateIndexCharsa));
CellMatrix intRateIndexChars(
	intRateIndexCharsb.AsCellMatrix("intRateIndexChars"));

XlfOper auxCurveFwdb(
	(auxCurveFwda));
CellMatrix auxCurveFwd(
	auxCurveFwdb.AsCellMatrix("auxCurveFwd"));

XlfOper auxCurveFloatingb(
	(auxCurveFloatinga));
CellMatrix auxCurveFloating(
	auxCurveFloatingb.AsCellMatrix("auxCurveFloating"));



XlfOper interpolatorb(
	(interpolatora));
string interpolator(
	interpolatorb.AsString("interpolator"));

CellMatrix result(
	checkBoostrappingFwdsFloating(
		xlValueDate,
		xlInputRates,
		xlInputForwards,
		whichLeg,
		xlInputFloatingLegs,
		holidays,
		intRateIndexChars,
		auxCurveFwd,
		auxCurveFloating,
		fx,
		fixing,
		interpolator)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCAddTenorToDateArgs[]=
{
{ "tenor","tenor 1M, 1Y, etc ","XLF_OPER"},
{ "startDate","Fecha inicial ","B"},
{ "holidays","Vector vertical con feriados ","XLF_OPER"},
{ "adjRule","Regla para ajustar en caso de dias inhabiles ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCAddTenorToDate("xlQCAddTenorToDate",
"QCAddTenorToDate",
"Suma un tenor a una fecha considerando feriados ",
LibraryName,
QCAddTenorToDateArgs,
4
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCAddTenorToDate(
LPXLFOPER tenora,
double startDate,
LPXLFOPER holidaysa,
LPXLFOPER adjRulea)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tenorb(
	(tenora));
string tenor(
	tenorb.AsString("tenor"));


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper adjRuleb(
	(adjRulea));
string adjRule(
	adjRuleb.AsString("adjRule"));

double result(
	QCAddTenorToDate(
		tenor,
		startDate,
		holidays,
		adjRule)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCAddChileTenorToDateArgs[]=
{
{ "tenor","tenor 1M, 1Y, etc ","XLF_OPER"},
{ "startDate","Fecha inicial ","B"},
{ "holidays","Vector vertical con feriados ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCAddChileTenorToDate("xlQCAddChileTenorToDate",
"QCAddChileTenorToDate",
"Suma un tenor a la chilena (termina dia 9 PREV) a una fecha considerando feriados ",
LibraryName,
QCAddChileTenorToDateArgs,
3
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCAddChileTenorToDate(
LPXLFOPER tenora,
double startDate,
LPXLFOPER holidaysa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tenorb(
	(tenora));
string tenor(
	tenorb.AsString("tenor"));


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

double result(
	QCAddChileTenorToDate(
		tenor,
		startDate,
		holidays)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCBusinessDateArgs[]=
{
{ "startDate","Fecha inicial ","B"},
{ "holidays","Vector vertical de feriados ","XLF_OPER"},
{ "adjRule","Regla de ajuste ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCBusinessDate("xlQCBusinessDate",
"QCBusinessDate",
"Calcula proxima o previa fecha habil segun regla y calendarios ",
LibraryName,
QCBusinessDateArgs,
3
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCBusinessDate(
double startDate,
LPXLFOPER holidaysa,
LPXLFOPER adjRulea)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper adjRuleb(
	(adjRulea));
string adjRule(
	adjRuleb.AsString("adjRule"));

double result(
	QCBusinessDate(
		startDate,
		holidays,
		adjRule)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCGetDateFromStringArgs[]=
{
{ "f","String que representa la fecha ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCGetDateFromString("xlQCGetDateFromString",
"QCGetDateFromString",
"Retorna una fecha como numero a partir de un string ",
LibraryName,
QCGetDateFromStringArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCGetDateFromString(
LPXLFOPER fa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper fb(
	(fa));
string f(
	fb.AsString("f"));

double result(
	QCGetDateFromString(
		f)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCGetYearFractionArgs[]=
{
{ "startDate","Fecha inicial ","B"},
{ "endDate","Fecha final ","B"},
{ "yf","Nombre de la fraccion de agno ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCGetYearFraction("xlQCGetYearFraction",
"QCGetYearFraction",
"Devuelve la fraccion de agno entre dos fechas ",
LibraryName,
QCGetYearFractionArgs,
3
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCGetYearFraction(
double startDatea,
double endDatea,
LPXLFOPER yfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

int startDate(
	static_cast<int>(startDatea));

int endDate(
	static_cast<int>(endDatea));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

double result(
	QCGetYearFraction(
		startDate,
		endDate,
		yf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCGetFwdRateFromCurveArgs[]=
{
{ "curva","Plazos y tasas de la curva ","XLF_OPER"},
{ "curveInterpolator","Tipo de interpolacion de la curva ","XLF_OPER"},
{ "curveYf","Fraccion de a o de las tasas de la curva ","XLF_OPER"},
{ "curveWf","Factor de capitalizacion de las tasas de la curva ","XLF_OPER"},
{ "plazo1","Plazo corto en dias ","B"},
{ "plazo2","Plazo largo en dias ","B"},
{ "rateYf","Fraccion de a o de la tasa forward ","XLF_OPER"},
{ "rateWf","Factor de capitalizacion de la tasa forward ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCGetFwdRateFromCurve("xlQCGetFwdRateFromCurve",
"QCGetFwdRateFromCurve",
"Devuelve tasa forward a partir de una curva ",
LibraryName,
QCGetFwdRateFromCurveArgs,
8
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCGetFwdRateFromCurve(
LPXLFOPER curvaa,
LPXLFOPER curveInterpolatora,
LPXLFOPER curveYfa,
LPXLFOPER curveWfa,
double plazo1,
double plazo2,
LPXLFOPER rateYfa,
LPXLFOPER rateWfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper curvab(
	(curvaa));
CellMatrix curva(
	curvab.AsCellMatrix("curva"));

XlfOper curveInterpolatorb(
	(curveInterpolatora));
string curveInterpolator(
	curveInterpolatorb.AsString("curveInterpolator"));

XlfOper curveYfb(
	(curveYfa));
string curveYf(
	curveYfb.AsString("curveYf"));

XlfOper curveWfb(
	(curveWfa));
string curveWf(
	curveWfb.AsString("curveWf"));



XlfOper rateYfb(
	(rateYfa));
string rateYf(
	rateYfb.AsString("rateYf"));

XlfOper rateWfb(
	(rateWfa));
string rateWf(
	rateWfb.AsString("rateWf"));

double result(
	QCGetFwdRateFromCurve(
		curva,
		curveInterpolator,
		curveYf,
		curveWf,
		plazo1,
		plazo2,
		rateYf,
		rateWf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCGetWealthFactorArgs[]=
{
{ "rate","Valor de la tasa ","B"},
{ "stDt","Fecha inicial ","B"},
{ "endDt","Fecha final ","B"},
{ "yf","Tipo de fraccion de agno ","XLF_OPER"},
{ "wf","Tipo de factor de capitalizacion ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCGetWealthFactor("xlQCGetWealthFactor",
"QCGetWealthFactor",
"Devuelve el factor de capitalizacion de una tasa entre 2 fechas ",
LibraryName,
QCGetWealthFactorArgs,
5
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCGetWealthFactor(
double rate,
double stDt,
double endDt,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);




XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

double result(
	QCGetWealthFactor(
		rate,
		stDt,
		endDt,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCGetDiscountFactorFromCurveArgs[]=
{
{ "curva","rango columna con plazos y tasas de la curva de descuento ","XLF_OPER"},
{ "curveInterpolator","tipo de interpolacion para la curva ","XLF_OPER"},
{ "curveYf","fraccion de a o de las tasas de la curva ","XLF_OPER"},
{ "curveWf","factor de capitalizacion de las tasas de la curva ","XLF_OPER"},
{ "plazo","plazo a interpolar ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCGetDiscountFactorFromCurve("xlQCGetDiscountFactorFromCurve",
"QCGetDiscountFactorFromCurve",
"Devuelve el factor de descuento al plazo a partir de una curva cero ",
LibraryName,
QCGetDiscountFactorFromCurveArgs,
5
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCGetDiscountFactorFromCurve(
LPXLFOPER curvaa,
LPXLFOPER curveInterpolatora,
LPXLFOPER curveYfa,
LPXLFOPER curveWfa,
double plazo)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper curvab(
	(curvaa));
CellMatrix curva(
	curvab.AsCellMatrix("curva"));

XlfOper curveInterpolatorb(
	(curveInterpolatora));
string curveInterpolator(
	curveInterpolatorb.AsString("curveInterpolator"));

XlfOper curveYfb(
	(curveYfa));
string curveYf(
	curveYfb.AsString("curveYf"));

XlfOper curveWfb(
	(curveWfa));
string curveWf(
	curveWfb.AsString("curveWf"));


double result(
	QCGetDiscountFactorFromCurve(
		curva,
		curveInterpolator,
		curveYf,
		curveWf,
		plazo)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCGetWealthFactorFwdFromCurveArgs[]=
{
{ "curva","rango columna con plazos y tasas de la curva de descuento ","XLF_OPER"},
{ "curveInterpolator","tipo de interpolacion para la curva ","XLF_OPER"},
{ "curveYf","fraccion de a o de las tasas de la curva ","XLF_OPER"},
{ "curveWf","factor de capitalizacion de las tasas de la curva ","XLF_OPER"},
{ "plazo1","plazo a interpolar 1 ","B"},
{ "plazo2","plazo a interpolar 2 ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCGetWealthFactorFwdFromCurve("xlQCGetWealthFactorFwdFromCurve",
"QCGetWealthFactorFwdFromCurve",
"Devuelve el factor de capitalizacion forward entre los plazos a partir de una curva cero ",
LibraryName,
QCGetWealthFactorFwdFromCurveArgs,
6
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCGetWealthFactorFwdFromCurve(
LPXLFOPER curvaa,
LPXLFOPER curveInterpolatora,
LPXLFOPER curveYfa,
LPXLFOPER curveWfa,
double plazo1,
double plazo2)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper curvab(
	(curvaa));
CellMatrix curva(
	curvab.AsCellMatrix("curva"));

XlfOper curveInterpolatorb(
	(curveInterpolatora));
string curveInterpolator(
	curveInterpolatorb.AsString("curveInterpolator"));

XlfOper curveYfb(
	(curveYfa));
string curveYf(
	curveYfb.AsString("curveYf"));

XlfOper curveWfb(
	(curveWfa));
string curveWf(
	curveWfb.AsString("curveWf"));



double result(
	QCGetWealthFactorFwdFromCurve(
		curva,
		curveInterpolator,
		curveYf,
		curveWf,
		plazo1,
		plazo2)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCGetDiscountFactorFwdFromCurveArgs[]=
{
{ "curva","rango columna con plazos y tasas de la curva de descuento ","XLF_OPER"},
{ "curveInterpolator","tipo de interpolacion para la curva ","XLF_OPER"},
{ "curveYf","fraccion de a o de las tasas de la curva ","XLF_OPER"},
{ "curveWf","factor de capitalizacion de las tasas de la curva ","XLF_OPER"},
{ "plazo1","plazo a interpolar 1 ","B"},
{ "plazo2","plazo a interpolar 2 ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCGetDiscountFactorFwdFromCurve("xlQCGetDiscountFactorFwdFromCurve",
"QCGetDiscountFactorFwdFromCurve",
"Devuelve el factor de descuento forward entre los plazos a partir de una curva cero ",
LibraryName,
QCGetDiscountFactorFwdFromCurveArgs,
6
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCGetDiscountFactorFwdFromCurve(
LPXLFOPER curvaa,
LPXLFOPER curveInterpolatora,
LPXLFOPER curveYfa,
LPXLFOPER curveWfa,
double plazo1,
double plazo2)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper curvab(
	(curvaa));
CellMatrix curva(
	curvab.AsCellMatrix("curva"));

XlfOper curveInterpolatorb(
	(curveInterpolatora));
string curveInterpolator(
	curveInterpolatorb.AsString("curveInterpolator"));

XlfOper curveYfb(
	(curveYfa));
string curveYf(
	curveYfb.AsString("curveYf"));

XlfOper curveWfb(
	(curveWfa));
string curveWf(
	curveWfb.AsString("curveWf"));



double result(
	QCGetDiscountFactorFwdFromCurve(
		curva,
		curveInterpolator,
		curveYf,
		curveWf,
		plazo1,
		plazo2)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
cashFlowArgs[]=
{
{ "tablaDesarrollo","too lazy to comment this one ","XLF_OPER"},
{ "tasa","too lazy to comment this one ","B"},
{ "fecha","too lazy to comment this one ","B"},
{ "yf","too lazy to comment this one ","XLF_OPER"},
{ "wf","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registercashFlow("xlcashFlow",
"cashFlow",
"too lazy to comment this function ",
LibraryName,
cashFlowArgs,
5
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlcashFlow(
LPXLFOPER tablaDesarrolloa,
double tasa,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));


int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

CellMatrix result(
	cashFlow(
		tablaDesarrollo,
		tasa,
		fecha,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCPvFixedRateLegArgs[]=
{
{ "tablaDesarrollo","vector de QCInterestRatePeriods de la pata ","XLF_OPER"},
{ "nominalAmortizacion","vector columna con nominal vigente y amortizacion ","XLF_OPER"},
{ "tasa","valor de la tasa fija de la operacion ","B"},
{ "fecha","fecha de valorizacion ","B"},
{ "yf","fraccion de a o de la tasa fija ","XLF_OPER"},
{ "wf","factor de capitalizacion de la tasa fija ","XLF_OPER"},
{ "curva","rango columna con plazos y tasas de la curva de descuento ","XLF_OPER"},
{ "curveInterpolator","tipo de interpolacion para la curva ","XLF_OPER"},
{ "curveYf","fraccion de a o de las tasas de la curva ","XLF_OPER"},
{ "curveWf","factor de capitalizacion de las tasas de la curva ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCPvFixedRateLeg("xlQCPvFixedRateLeg",
"QCPvFixedRateLeg",
"Calcula el valor presente de una pata fija ",
LibraryName,
QCPvFixedRateLegArgs,
10
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCPvFixedRateLeg(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER nominalAmortizaciona,
double tasa,
double fecha,
LPXLFOPER yfa,
LPXLFOPER wfa,
LPXLFOPER curvaa,
LPXLFOPER curveInterpolatora,
LPXLFOPER curveYfa,
LPXLFOPER curveWfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper nominalAmortizacionb(
	(nominalAmortizaciona));
CellMatrix nominalAmortizacion(
	nominalAmortizacionb.AsCellMatrix("nominalAmortizacion"));



XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

XlfOper curvab(
	(curvaa));
CellMatrix curva(
	curvab.AsCellMatrix("curva"));

XlfOper curveInterpolatorb(
	(curveInterpolatora));
string curveInterpolator(
	curveInterpolatorb.AsString("curveInterpolator"));

XlfOper curveYfb(
	(curveYfa));
string curveYf(
	curveYfb.AsString("curveYf"));

XlfOper curveWfb(
	(curveWfa));
string curveWf(
	curveWfb.AsString("curveWf"));

double result(
	QCPvFixedRateLeg(
		tablaDesarrollo,
		nominalAmortizacion,
		tasa,
		fecha,
		yf,
		wf,
		curva,
		curveInterpolator,
		curveYf,
		curveWf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCPvIcpClpArgs[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "nominalAmortizacion","vector columna con nominal vigente y amortizacion ","XLF_OPER"},
{ "fecha","fecha de valorizacion ","B"},
{ "addSpread","Spread aditivo ","B"},
{ "curva","Curva de proyeccion ","XLF_OPER"},
{ "curveInterpolator","tipo de interpolacion para la curva ","XLF_OPER"},
{ "curveYf","fraccion de a o de las tasas de la curva ","XLF_OPER"},
{ "curveWf","factor de capitalizacion de las tasas de la curva ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCPvIcpClp("xlQCPvIcpClp",
"QCPvIcpClp",
"too lazy to comment this function ",
LibraryName,
QCPvIcpClpArgs,
8
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCPvIcpClp(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER nominalAmortizaciona,
double fecha,
double addSpread,
LPXLFOPER curvaa,
LPXLFOPER curveInterpolatora,
LPXLFOPER curveYfa,
LPXLFOPER curveWfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper nominalAmortizacionb(
	(nominalAmortizaciona));
CellMatrix nominalAmortizacion(
	nominalAmortizacionb.AsCellMatrix("nominalAmortizacion"));



XlfOper curvab(
	(curvaa));
CellMatrix curva(
	curvab.AsCellMatrix("curva"));

XlfOper curveInterpolatorb(
	(curveInterpolatora));
string curveInterpolator(
	curveInterpolatorb.AsString("curveInterpolator"));

XlfOper curveYfb(
	(curveYfa));
string curveYf(
	curveYfb.AsString("curveYf"));

XlfOper curveWfb(
	(curveWfa));
string curveWf(
	curveWfb.AsString("curveWf"));

double result(
	QCPvIcpClp(
		tablaDesarrollo,
		nominalAmortizacion,
		fecha,
		addSpread,
		curva,
		curveInterpolator,
		curveYf,
		curveWf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
QCPvFloatingLegArgs[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "nominalAmortizacion","Rango con dos columnas con nominal vigente y amortizacion por periodo ","XLF_OPER"},
{ "fecha","Fecha de valorizacion ","B"},
{ "curvaProy","Rango con dos columnas con plazos y tasas curva proyeccion ","XLF_OPER"},
{ "projCurveInterpolator","Metodo de interpolacion de la curva de proyeccion ","XLF_OPER"},
{ "projCurveYf","Fraccion de ano de las tasas de la curva de proyeccion ","XLF_OPER"},
{ "projCurveWf","Factor de capitalizacion de las tasas de la curva de proyeccion ","XLF_OPER"},
{ "curvaDesc","Rango con dos columnas con plazos y tasas de la curva de descuento ","XLF_OPER"},
{ "discCurveInterpolator","Metodo de interpolacion de la curva de descuento ","XLF_OPER"},
{ "discCurveYf","Fraccion de ano de las tasas de la curva de descuento ","XLF_OPER"},
{ "discCurveWf","Factor de capitalizacion de las tasas de la curva de descuento ","XLF_OPER"},
{ "pastFixings","Rango con dos columnas con fechas y tasas para fixing ","XLF_OPER"},
{ "addSpread","Valor del spread sobre tasa flotante ","B"},
{ "multSpread","Valor del spread multiplicativo ","B"},
{ "yf","Fraccion de ano de la tasa flotante ","XLF_OPER"},
{ "wf","Factor de capitalizacion de la tasa flotante ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerQCPvFloatingLeg("xlQCPvFloatingLeg",
"QCPvFloatingLeg",
"too lazy to comment this function ",
LibraryName,
QCPvFloatingLegArgs,
16
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlQCPvFloatingLeg(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER nominalAmortizaciona,
double fecha,
LPXLFOPER curvaProya,
LPXLFOPER projCurveInterpolatora,
LPXLFOPER projCurveYfa,
LPXLFOPER projCurveWfa,
LPXLFOPER curvaDesca,
LPXLFOPER discCurveInterpolatora,
LPXLFOPER discCurveYfa,
LPXLFOPER discCurveWfa,
LPXLFOPER pastFixingsa,
double addSpread,
double multSpread,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper nominalAmortizacionb(
	(nominalAmortizaciona));
CellMatrix nominalAmortizacion(
	nominalAmortizacionb.AsCellMatrix("nominalAmortizacion"));


XlfOper curvaProyb(
	(curvaProya));
CellMatrix curvaProy(
	curvaProyb.AsCellMatrix("curvaProy"));

XlfOper projCurveInterpolatorb(
	(projCurveInterpolatora));
string projCurveInterpolator(
	projCurveInterpolatorb.AsString("projCurveInterpolator"));

XlfOper projCurveYfb(
	(projCurveYfa));
string projCurveYf(
	projCurveYfb.AsString("projCurveYf"));

XlfOper projCurveWfb(
	(projCurveWfa));
string projCurveWf(
	projCurveWfb.AsString("projCurveWf"));

XlfOper curvaDescb(
	(curvaDesca));
CellMatrix curvaDesc(
	curvaDescb.AsCellMatrix("curvaDesc"));

XlfOper discCurveInterpolatorb(
	(discCurveInterpolatora));
string discCurveInterpolator(
	discCurveInterpolatorb.AsString("discCurveInterpolator"));

XlfOper discCurveYfb(
	(discCurveYfa));
string discCurveYf(
	discCurveYfb.AsString("discCurveYf"));

XlfOper discCurveWfb(
	(discCurveWfa));
string discCurveWf(
	discCurveWfb.AsString("discCurveWf"));

XlfOper pastFixingsb(
	(pastFixingsa));
CellMatrix pastFixings(
	pastFixingsb.AsCellMatrix("pastFixings"));



XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

double result(
	QCPvFloatingLeg(
		tablaDesarrollo,
		nominalAmortizacion,
		fecha,
		curvaProy,
		projCurveInterpolator,
		projCurveYf,
		projCurveWf,
		curvaDesc,
		discCurveInterpolator,
		discCurveYf,
		discCurveWf,
		pastFixings,
		addSpread,
		multSpread,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvFixed1Args[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "curva","Curva cero cupon (rango con tenors y tasas) ","XLF_OPER"},
{ "tasa","valor de la tasa fija de la pata ","B"},
{ "fecha","fecha de valorizacion ","B"},
{ "yf","nombre de la fraccion de agno de la tasa fija ","XLF_OPER"},
{ "wf","nombre del tipo de factor de capitalizacion ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvFixed1("xlpvFixed1",
"pvFixed1",
"too lazy to comment this function ",
LibraryName,
pvFixed1Args,
6
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvFixed1(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER curvaa,
double tasa,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper curvab(
	(curvaa));
CellMatrix curva(
	curvab.AsCellMatrix("curva"));


int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

double result(
	pvFixed1(
		tablaDesarrollo,
		curva,
		tasa,
		fecha,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvFloat1Args[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "curvaProy","Curva de proyeccion ","XLF_OPER"},
{ "curvaDesc","Curva de descuento ","XLF_OPER"},
{ "pastFixings","Fixings anteriores ","XLF_OPER"},
{ "addSpread","Spread aditivo ","B"},
{ "multSpread","Spread multiplicativo ","B"},
{ "fecha","Fecha de valorizacion ","B"},
{ "yf","Yf de la tasa flotante ","XLF_OPER"},
{ "wf","Wf de la tasa flotante ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvFloat1("xlpvFloat1",
"pvFloat1",
"too lazy to comment this function ",
LibraryName,
pvFloat1Args,
9
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvFloat1(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER curvaProya,
LPXLFOPER curvaDesca,
LPXLFOPER pastFixingsa,
double addSpread,
double multSpread,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper curvaProyb(
	(curvaProya));
CellMatrix curvaProy(
	curvaProyb.AsCellMatrix("curvaProy"));

XlfOper curvaDescb(
	(curvaDesca));
CellMatrix curvaDesc(
	curvaDescb.AsCellMatrix("curvaDesc"));

XlfOper pastFixingsb(
	(pastFixingsa));
CellMatrix pastFixings(
	pastFixingsb.AsCellMatrix("pastFixings"));



int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

double result(
	pvFloat1(
		tablaDesarrollo,
		curvaProy,
		curvaDesc,
		pastFixings,
		addSpread,
		multSpread,
		fecha,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvIcpClp1Args[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "curvaProy","Curva de proyeccion ","XLF_OPER"},
{ "curvaDesc","Curva de descuento ","XLF_OPER"},
{ "pastFixings","Fixings pasados de ICP ","XLF_OPER"},
{ "addSpread","Spread aditivo ","B"},
{ "multSpread","Spread multiplicativo ","B"},
{ "fecha","Fecha de valorizacion ","B"},
{ "yf","Fraccion de a o de la tasa flotante ","XLF_OPER"},
{ "wf","Factor de capitalizacion de la tasa flotante ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvIcpClp1("xlpvIcpClp1",
"pvIcpClp1",
"too lazy to comment this function ",
LibraryName,
pvIcpClp1Args,
9
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvIcpClp1(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER curvaProya,
LPXLFOPER curvaDesca,
LPXLFOPER pastFixingsa,
double addSpread,
double multSpread,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper curvaProyb(
	(curvaProya));
CellMatrix curvaProy(
	curvaProyb.AsCellMatrix("curvaProy"));

XlfOper curvaDescb(
	(curvaDesca));
CellMatrix curvaDesc(
	curvaDescb.AsCellMatrix("curvaDesc"));

XlfOper pastFixingsb(
	(pastFixingsa));
CellMatrix pastFixings(
	pastFixingsb.AsCellMatrix("pastFixings"));



int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

double result(
	pvIcpClp1(
		tablaDesarrollo,
		curvaProy,
		curvaDesc,
		pastFixings,
		addSpread,
		multSpread,
		fecha,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvIcpClpArgs[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "curvaProy","Curva de proyeccion ","XLF_OPER"},
{ "curvaDesc","Curva de descuento ","XLF_OPER"},
{ "pastFixings","Fixings pasados de ICP ","XLF_OPER"},
{ "addSpread","Spread aditivo ","B"},
{ "multSpread","Spread multiplicativo ","B"},
{ "fecha","Fecha de valorizacion ","B"},
{ "yf","Fraccion de a o de la tasa flotante ","XLF_OPER"},
{ "wf","Factor de capitalizacion de la tasa flotante ","XLF_OPER"},
{ "curveYf","Fraccion de agno de la curva ","XLF_OPER"},
{ "curveWf","Factor de capitalizacion de la curva ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvIcpClp("xlpvIcpClp",
"pvIcpClp",
"too lazy to comment this function ",
LibraryName,
pvIcpClpArgs,
11
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvIcpClp(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER curvaProya,
LPXLFOPER curvaDesca,
LPXLFOPER pastFixingsa,
double addSpread,
double multSpread,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa,
LPXLFOPER curveYfa,
LPXLFOPER curveWfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper curvaProyb(
	(curvaProya));
CellMatrix curvaProy(
	curvaProyb.AsCellMatrix("curvaProy"));

XlfOper curvaDescb(
	(curvaDesca));
CellMatrix curvaDesc(
	curvaDescb.AsCellMatrix("curvaDesc"));

XlfOper pastFixingsb(
	(pastFixingsa));
CellMatrix pastFixings(
	pastFixingsb.AsCellMatrix("pastFixings"));



int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

XlfOper curveYfb(
	(curveYfa));
string curveYf(
	curveYfb.AsString("curveYf"));

XlfOper curveWfb(
	(curveWfa));
string curveWf(
	curveWfb.AsString("curveWf"));

double result(
	pvIcpClp(
		tablaDesarrollo,
		curvaProy,
		curvaDesc,
		pastFixings,
		addSpread,
		multSpread,
		fecha,
		yf,
		wf,
		curveYf,
		curveWf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvIcpClfArgs[]=
{
{ "tablaDesarrollo","Tabla de desarrollo de la pata ","XLF_OPER"},
{ "curvaProy","Curva de proyeccion ","XLF_OPER"},
{ "curvaDesc","Curva de descuento ","XLF_OPER"},
{ "pastFixings","Fixings pasados de ICP ","XLF_OPER"},
{ "ufFixings","Fixings pasado de UF ","XLF_OPER"},
{ "addSpread","Spread aditivo ","B"},
{ "multSpread","Spread multiplicativo ","B"},
{ "fecha","Fecha de valorizacion ","B"},
{ "yf","Fraccion de a o de la tasa flotante ","XLF_OPER"},
{ "wf","Factor de capitalizacion de la tasa flotante ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvIcpClf("xlpvIcpClf",
"pvIcpClf",
"too lazy to comment this function ",
LibraryName,
pvIcpClfArgs,
10
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvIcpClf(
LPXLFOPER tablaDesarrolloa,
LPXLFOPER curvaProya,
LPXLFOPER curvaDesca,
LPXLFOPER pastFixingsa,
LPXLFOPER ufFixingsa,
double addSpread,
double multSpread,
double fechaa,
LPXLFOPER yfa,
LPXLFOPER wfa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper tablaDesarrollob(
	(tablaDesarrolloa));
CellMatrix tablaDesarrollo(
	tablaDesarrollob.AsCellMatrix("tablaDesarrollo"));

XlfOper curvaProyb(
	(curvaProya));
CellMatrix curvaProy(
	curvaProyb.AsCellMatrix("curvaProy"));

XlfOper curvaDescb(
	(curvaDesca));
CellMatrix curvaDesc(
	curvaDescb.AsCellMatrix("curvaDesc"));

XlfOper pastFixingsb(
	(pastFixingsa));
CellMatrix pastFixings(
	pastFixingsb.AsCellMatrix("pastFixings"));

XlfOper ufFixingsb(
	(ufFixingsa));
CellMatrix ufFixings(
	ufFixingsb.AsCellMatrix("ufFixings"));



int fecha(
	static_cast<int>(fechaa));

XlfOper yfb(
	(yfa));
string yf(
	yfb.AsString("yf"));

XlfOper wfb(
	(wfa));
string wf(
	wfb.AsString("wf"));

double result(
	pvIcpClf(
		tablaDesarrollo,
		curvaProy,
		curvaDesc,
		pastFixings,
		ufFixings,
		addSpread,
		multSpread,
		fecha,
		yf,
		wf)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvFixedLegsArgs[]=
{
{ "valueDate","too lazy to comment this one ","B"},
{ "holidays","too lazy to comment this one ","XLF_OPER"},
{ "curveValues","too lazy to comment this one ","XLF_OPER"},
{ "curveCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "legCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "customAmort","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvFixedLegs("xlpvFixedLegs",
"pvFixedLegs",
"too lazy to comment this function ",
LibraryName,
pvFixedLegsArgs,
6
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvFixedLegs(
double valueDate,
LPXLFOPER holidaysa,
LPXLFOPER curveValuesa,
LPXLFOPER curveCharacteristicsa,
LPXLFOPER legCharacteristicsa,
LPXLFOPER customAmorta)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper curveValuesb(
	(curveValuesa));
CellMatrix curveValues(
	curveValuesb.AsCellMatrix("curveValues"));

XlfOper curveCharacteristicsb(
	(curveCharacteristicsa));
CellMatrix curveCharacteristics(
	curveCharacteristicsb.AsCellMatrix("curveCharacteristics"));

XlfOper legCharacteristicsb(
	(legCharacteristicsa));
CellMatrix legCharacteristics(
	legCharacteristicsb.AsCellMatrix("legCharacteristics"));

XlfOper customAmortb(
	(customAmorta));
CellMatrix customAmort(
	customAmortb.AsCellMatrix("customAmort"));

CellMatrix result(
	pvFixedLegs(
		valueDate,
		holidays,
		curveValues,
		curveCharacteristics,
		legCharacteristics,
		customAmort)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvFixedLegs2Args[]=
{
{ "valueDate","too lazy to comment this one ","B"},
{ "holidays","too lazy to comment this one ","XLF_OPER"},
{ "curveValues","too lazy to comment this one ","XLF_OPER"},
{ "curveCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "legCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "customAmort","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvFixedLegs2("xlpvFixedLegs2",
"pvFixedLegs2",
"too lazy to comment this function ",
LibraryName,
pvFixedLegs2Args,
6
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvFixedLegs2(
double valueDate,
LPXLFOPER holidaysa,
LPXLFOPER curveValuesa,
LPXLFOPER curveCharacteristicsa,
LPXLFOPER legCharacteristicsa,
LPXLFOPER customAmorta)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper curveValuesb(
	(curveValuesa));
CellMatrix curveValues(
	curveValuesb.AsCellMatrix("curveValues"));

XlfOper curveCharacteristicsb(
	(curveCharacteristicsa));
CellMatrix curveCharacteristics(
	curveCharacteristicsb.AsCellMatrix("curveCharacteristics"));

XlfOper legCharacteristicsb(
	(legCharacteristicsa));
CellMatrix legCharacteristics(
	legCharacteristicsb.AsCellMatrix("legCharacteristics"));

XlfOper customAmortb(
	(customAmorta));
CellMatrix customAmort(
	customAmortb.AsCellMatrix("customAmort"));

CellMatrix result(
	pvFixedLegs2(
		valueDate,
		holidays,
		curveValues,
		curveCharacteristics,
		legCharacteristics,
		customAmort)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvIcpClpLegsArgs[]=
{
{ "valueDate","too lazy to comment this one ","B"},
{ "holidays","too lazy to comment this one ","XLF_OPER"},
{ "curveValues","too lazy to comment this one ","XLF_OPER"},
{ "curveCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "legCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "customAmort","too lazy to comment this one ","XLF_OPER"},
{ "fixings","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvIcpClpLegs("xlpvIcpClpLegs",
"pvIcpClpLegs",
"too lazy to comment this function ",
LibraryName,
pvIcpClpLegsArgs,
7
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvIcpClpLegs(
double valueDate,
LPXLFOPER holidaysa,
LPXLFOPER curveValuesa,
LPXLFOPER curveCharacteristicsa,
LPXLFOPER legCharacteristicsa,
LPXLFOPER customAmorta,
LPXLFOPER fixingsa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper curveValuesb(
	(curveValuesa));
CellMatrix curveValues(
	curveValuesb.AsCellMatrix("curveValues"));

XlfOper curveCharacteristicsb(
	(curveCharacteristicsa));
CellMatrix curveCharacteristics(
	curveCharacteristicsb.AsCellMatrix("curveCharacteristics"));

XlfOper legCharacteristicsb(
	(legCharacteristicsa));
CellMatrix legCharacteristics(
	legCharacteristicsb.AsCellMatrix("legCharacteristics"));

XlfOper customAmortb(
	(customAmorta));
CellMatrix customAmort(
	customAmortb.AsCellMatrix("customAmort"));

XlfOper fixingsb(
	(fixingsa));
CellMatrix fixings(
	fixingsb.AsCellMatrix("fixings"));

CellMatrix result(
	pvIcpClpLegs(
		valueDate,
		holidays,
		curveValues,
		curveCharacteristics,
		legCharacteristics,
		customAmort,
		fixings)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvIcpClpLegs2Args[]=
{
{ "valueDate","too lazy to comment this one ","B"},
{ "holidays","too lazy to comment this one ","XLF_OPER"},
{ "curveValues","too lazy to comment this one ","XLF_OPER"},
{ "curveCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "legCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "customAmort","too lazy to comment this one ","XLF_OPER"},
{ "fixings","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvIcpClpLegs2("xlpvIcpClpLegs2",
"pvIcpClpLegs2",
"too lazy to comment this function ",
LibraryName,
pvIcpClpLegs2Args,
7
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvIcpClpLegs2(
double valueDate,
LPXLFOPER holidaysa,
LPXLFOPER curveValuesa,
LPXLFOPER curveCharacteristicsa,
LPXLFOPER legCharacteristicsa,
LPXLFOPER customAmorta,
LPXLFOPER fixingsa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper curveValuesb(
	(curveValuesa));
CellMatrix curveValues(
	curveValuesb.AsCellMatrix("curveValues"));

XlfOper curveCharacteristicsb(
	(curveCharacteristicsa));
CellMatrix curveCharacteristics(
	curveCharacteristicsb.AsCellMatrix("curveCharacteristics"));

XlfOper legCharacteristicsb(
	(legCharacteristicsa));
CellMatrix legCharacteristics(
	legCharacteristicsb.AsCellMatrix("legCharacteristics"));

XlfOper customAmortb(
	(customAmorta));
CellMatrix customAmort(
	customAmortb.AsCellMatrix("customAmort"));

XlfOper fixingsb(
	(fixingsa));
CellMatrix fixings(
	fixingsb.AsCellMatrix("fixings"));

CellMatrix result(
	pvIcpClpLegs2(
		valueDate,
		holidays,
		curveValues,
		curveCharacteristics,
		legCharacteristics,
		customAmort,
		fixings)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvIcpClfLegsArgs[]=
{
{ "valueDate","too lazy to comment this one ","B"},
{ "holidays","too lazy to comment this one ","XLF_OPER"},
{ "curveValues","too lazy to comment this one ","XLF_OPER"},
{ "curveCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "legCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "customAmort","too lazy to comment this one ","XLF_OPER"},
{ "icpFixings","too lazy to comment this one ","XLF_OPER"},
{ "ufFixings","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvIcpClfLegs("xlpvIcpClfLegs",
"pvIcpClfLegs",
"too lazy to comment this function ",
LibraryName,
pvIcpClfLegsArgs,
8
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvIcpClfLegs(
double valueDate,
LPXLFOPER holidaysa,
LPXLFOPER curveValuesa,
LPXLFOPER curveCharacteristicsa,
LPXLFOPER legCharacteristicsa,
LPXLFOPER customAmorta,
LPXLFOPER icpFixingsa,
LPXLFOPER ufFixingsa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper curveValuesb(
	(curveValuesa));
CellMatrix curveValues(
	curveValuesb.AsCellMatrix("curveValues"));

XlfOper curveCharacteristicsb(
	(curveCharacteristicsa));
CellMatrix curveCharacteristics(
	curveCharacteristicsb.AsCellMatrix("curveCharacteristics"));

XlfOper legCharacteristicsb(
	(legCharacteristicsa));
CellMatrix legCharacteristics(
	legCharacteristicsb.AsCellMatrix("legCharacteristics"));

XlfOper customAmortb(
	(customAmorta));
CellMatrix customAmort(
	customAmortb.AsCellMatrix("customAmort"));

XlfOper icpFixingsb(
	(icpFixingsa));
CellMatrix icpFixings(
	icpFixingsb.AsCellMatrix("icpFixings"));

XlfOper ufFixingsb(
	(ufFixingsa));
CellMatrix ufFixings(
	ufFixingsb.AsCellMatrix("ufFixings"));

CellMatrix result(
	pvIcpClfLegs(
		valueDate,
		holidays,
		curveValues,
		curveCharacteristics,
		legCharacteristics,
		customAmort,
		icpFixings,
		ufFixings)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvIcpClfLegs2Args[]=
{
{ "valueDate","too lazy to comment this one ","B"},
{ "holidays","too lazy to comment this one ","XLF_OPER"},
{ "curveValues","too lazy to comment this one ","XLF_OPER"},
{ "curveCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "legCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "customAmort","too lazy to comment this one ","XLF_OPER"},
{ "icpFixings","too lazy to comment this one ","XLF_OPER"},
{ "ufFixings","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvIcpClfLegs2("xlpvIcpClfLegs2",
"pvIcpClfLegs2",
"too lazy to comment this function ",
LibraryName,
pvIcpClfLegs2Args,
8
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvIcpClfLegs2(
double valueDate,
LPXLFOPER holidaysa,
LPXLFOPER curveValuesa,
LPXLFOPER curveCharacteristicsa,
LPXLFOPER legCharacteristicsa,
LPXLFOPER customAmorta,
LPXLFOPER icpFixingsa,
LPXLFOPER ufFixingsa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper curveValuesb(
	(curveValuesa));
CellMatrix curveValues(
	curveValuesb.AsCellMatrix("curveValues"));

XlfOper curveCharacteristicsb(
	(curveCharacteristicsa));
CellMatrix curveCharacteristics(
	curveCharacteristicsb.AsCellMatrix("curveCharacteristics"));

XlfOper legCharacteristicsb(
	(legCharacteristicsa));
CellMatrix legCharacteristics(
	legCharacteristicsb.AsCellMatrix("legCharacteristics"));

XlfOper customAmortb(
	(customAmorta));
CellMatrix customAmort(
	customAmortb.AsCellMatrix("customAmort"));

XlfOper icpFixingsb(
	(icpFixingsa));
CellMatrix icpFixings(
	icpFixingsb.AsCellMatrix("icpFixings"));

XlfOper ufFixingsb(
	(ufFixingsa));
CellMatrix ufFixings(
	ufFixingsb.AsCellMatrix("ufFixings"));

CellMatrix result(
	pvIcpClfLegs2(
		valueDate,
		holidays,
		curveValues,
		curveCharacteristics,
		legCharacteristics,
		customAmort,
		icpFixings,
		ufFixings)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
buildInterestRateLegArgs[]=
{
{ "startDate","too lazy to comment this one ","B"},
{ "endDate","too lazy to comment this one ","B"},
{ "calendars","too lazy to comment this one ","XLF_OPER"},
{ "settlementStubPeriod","too lazy to comment this one ","XLF_OPER"},
{ "settlementPeriodicity","too lazy to comment this one ","XLF_OPER"},
{ "endDateAdjustment","too lazy to comment this one ","XLF_OPER"},
{ "settlementCalendar","too lazy to comment this one ","XLF_OPER"},
{ "settlementLag","too lazy to comment this one ","B"},
{ "fixingStubPeriod","too lazy to comment this one ","XLF_OPER"},
{ "fixingPeriodicity","too lazy to comment this one ","XLF_OPER"},
{ "fixingLag","too lazy to comment this one ","B"},
{ "fixingCalendar","too lazy to comment this one ","XLF_OPER"},
{ "fixingStartDateRule","too lazy to comment this one ","B"},
{ "fixingTenor","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerbuildInterestRateLeg("xlbuildInterestRateLeg",
"buildInterestRateLeg",
"too lazy to comment this function ",
LibraryName,
buildInterestRateLegArgs,
14
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlbuildInterestRateLeg(
double startDate,
double endDate,
LPXLFOPER calendarsa,
LPXLFOPER settlementStubPerioda,
LPXLFOPER settlementPeriodicitya,
LPXLFOPER endDateAdjustmenta,
LPXLFOPER settlementCalendara,
double settlementLaga,
LPXLFOPER fixingStubPerioda,
LPXLFOPER fixingPeriodicitya,
double fixingLaga,
LPXLFOPER fixingCalendara,
double fixingStartDateRulea,
LPXLFOPER fixingTenora)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);



XlfOper calendarsb(
	(calendarsa));
CellMatrix calendars(
	calendarsb.AsCellMatrix("calendars"));

XlfOper settlementStubPeriodb(
	(settlementStubPerioda));
string settlementStubPeriod(
	settlementStubPeriodb.AsString("settlementStubPeriod"));

XlfOper settlementPeriodicityb(
	(settlementPeriodicitya));
string settlementPeriodicity(
	settlementPeriodicityb.AsString("settlementPeriodicity"));

XlfOper endDateAdjustmentb(
	(endDateAdjustmenta));
string endDateAdjustment(
	endDateAdjustmentb.AsString("endDateAdjustment"));

XlfOper settlementCalendarb(
	(settlementCalendara));
string settlementCalendar(
	settlementCalendarb.AsString("settlementCalendar"));

int settlementLag(
	static_cast<int>(settlementLaga));

XlfOper fixingStubPeriodb(
	(fixingStubPerioda));
string fixingStubPeriod(
	fixingStubPeriodb.AsString("fixingStubPeriod"));

XlfOper fixingPeriodicityb(
	(fixingPeriodicitya));
string fixingPeriodicity(
	fixingPeriodicityb.AsString("fixingPeriodicity"));

int fixingLag(
	static_cast<int>(fixingLaga));

XlfOper fixingCalendarb(
	(fixingCalendara));
string fixingCalendar(
	fixingCalendarb.AsString("fixingCalendar"));

int fixingStartDateRule(
	static_cast<int>(fixingStartDateRulea));

XlfOper fixingTenorb(
	(fixingTenora));
string fixingTenor(
	fixingTenorb.AsString("fixingTenor"));

CellMatrix result(
	buildInterestRateLeg(
		startDate,
		endDate,
		calendars,
		settlementStubPeriod,
		settlementPeriodicity,
		endDateAdjustment,
		settlementCalendar,
		settlementLag,
		fixingStubPeriod,
		fixingPeriodicity,
		fixingLag,
		fixingCalendar,
		fixingStartDateRule,
		fixingTenor)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvFloatingRateLegsArgs[]=
{
{ "valueDate","too lazy to comment this one ","B"},
{ "holidays","too lazy to comment this one ","XLF_OPER"},
{ "curveValues","too lazy to comment this one ","XLF_OPER"},
{ "curveCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "legCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "customAmort","too lazy to comment this one ","XLF_OPER"},
{ "fixings","too lazy to comment this one ","XLF_OPER"},
{ "intRateIndexChars","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvFloatingRateLegs("xlpvFloatingRateLegs",
"pvFloatingRateLegs",
"too lazy to comment this function ",
LibraryName,
pvFloatingRateLegsArgs,
8
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvFloatingRateLegs(
double valueDate,
LPXLFOPER holidaysa,
LPXLFOPER curveValuesa,
LPXLFOPER curveCharacteristicsa,
LPXLFOPER legCharacteristicsa,
LPXLFOPER customAmorta,
LPXLFOPER fixingsa,
LPXLFOPER intRateIndexCharsa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper curveValuesb(
	(curveValuesa));
CellMatrix curveValues(
	curveValuesb.AsCellMatrix("curveValues"));

XlfOper curveCharacteristicsb(
	(curveCharacteristicsa));
CellMatrix curveCharacteristics(
	curveCharacteristicsb.AsCellMatrix("curveCharacteristics"));

XlfOper legCharacteristicsb(
	(legCharacteristicsa));
CellMatrix legCharacteristics(
	legCharacteristicsb.AsCellMatrix("legCharacteristics"));

XlfOper customAmortb(
	(customAmorta));
CellMatrix customAmort(
	customAmortb.AsCellMatrix("customAmort"));

XlfOper fixingsb(
	(fixingsa));
CellMatrix fixings(
	fixingsb.AsCellMatrix("fixings"));

XlfOper intRateIndexCharsb(
	(intRateIndexCharsa));
CellMatrix intRateIndexChars(
	intRateIndexCharsb.AsCellMatrix("intRateIndexChars"));

CellMatrix result(
	pvFloatingRateLegs(
		valueDate,
		holidays,
		curveValues,
		curveCharacteristics,
		legCharacteristics,
		customAmort,
		fixings,
		intRateIndexChars)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
pvFloatingRateLegs2Args[]=
{
{ "valueDate","too lazy to comment this one ","B"},
{ "holidays","too lazy to comment this one ","XLF_OPER"},
{ "curveValues","too lazy to comment this one ","XLF_OPER"},
{ "curveCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "legCharacteristics","too lazy to comment this one ","XLF_OPER"},
{ "customAmort","too lazy to comment this one ","XLF_OPER"},
{ "fixings","too lazy to comment this one ","XLF_OPER"},
{ "intRateIndexChars","too lazy to comment this one ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerpvFloatingRateLegs2("xlpvFloatingRateLegs2",
"pvFloatingRateLegs2",
"too lazy to comment this function ",
LibraryName,
pvFloatingRateLegs2Args,
8
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlpvFloatingRateLegs2(
double valueDate,
LPXLFOPER holidaysa,
LPXLFOPER curveValuesa,
LPXLFOPER curveCharacteristicsa,
LPXLFOPER legCharacteristicsa,
LPXLFOPER customAmorta,
LPXLFOPER fixingsa,
LPXLFOPER intRateIndexCharsa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


XlfOper holidaysb(
	(holidaysa));
CellMatrix holidays(
	holidaysb.AsCellMatrix("holidays"));

XlfOper curveValuesb(
	(curveValuesa));
CellMatrix curveValues(
	curveValuesb.AsCellMatrix("curveValues"));

XlfOper curveCharacteristicsb(
	(curveCharacteristicsa));
CellMatrix curveCharacteristics(
	curveCharacteristicsb.AsCellMatrix("curveCharacteristics"));

XlfOper legCharacteristicsb(
	(legCharacteristicsa));
CellMatrix legCharacteristics(
	legCharacteristicsb.AsCellMatrix("legCharacteristics"));

XlfOper customAmortb(
	(customAmorta));
CellMatrix customAmort(
	customAmortb.AsCellMatrix("customAmort"));

XlfOper fixingsb(
	(fixingsa));
CellMatrix fixings(
	fixingsb.AsCellMatrix("fixings"));

XlfOper intRateIndexCharsb(
	(intRateIndexCharsa));
CellMatrix intRateIndexChars(
	intRateIndexCharsb.AsCellMatrix("intRateIndexChars"));

CellMatrix result(
	pvFloatingRateLegs2(
		valueDate,
		holidays,
		curveValues,
		curveCharacteristics,
		legCharacteristics,
		customAmort,
		fixings,
		intRateIndexChars)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

//////////////////////////
// Methods that will get registered to execute in AutoOpen
//////////////////////////

//////////////////////////
// Methods that will get registered to execute in AutoClose
//////////////////////////

